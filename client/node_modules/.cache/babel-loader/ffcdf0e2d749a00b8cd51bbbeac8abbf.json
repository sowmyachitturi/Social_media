{"ast":null,"code":"// src/queriesObserver.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { QueryObserver } from \"./queryObserver.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { replaceEqualDeep } from \"./utils.js\";\n\nfunction difference(array1, array2) {\n  return array1.filter(x => !array2.includes(x));\n}\n\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\n\nvar QueriesObserver = class extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #options;\n  #observers;\n  #combinedResult;\n  #lastCombine;\n  #lastResult;\n  #observerMatches = [];\n\n  constructor(client, queries, options) {\n    super();\n    this.#client = client;\n    this.#options = options;\n    this.#queries = [];\n    this.#observers = [];\n    this.#result = [];\n    this.setQueries(queries);\n  }\n\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    this.#observers.forEach(observer => {\n      observer.destroy();\n    });\n  }\n\n  setQueries(queries, options, notifyOptions) {\n    this.#queries = queries;\n    this.#options = options;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      const queryHashes = queries.map(query => this.#client.defaultQueryOptions(query).queryHash);\n\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\"[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.\");\n      }\n    }\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n      this.#observerMatches = newObserverMatches;\n      newObserverMatches.forEach(match => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));\n      const newObservers = newObserverMatches.map(match => match.observer);\n      const newResult = newObservers.map(observer => observer.getCurrentResult());\n      const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n\n      this.#observers = newObservers;\n      this.#result = newResult;\n\n      if (!this.hasListeners()) {\n        return;\n      }\n\n      difference(prevObservers, newObservers).forEach(observer => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach(observer => {\n        observer.subscribe(result => {\n          this.#onUpdate(observer, result);\n        });\n      });\n      this.#notify();\n    });\n  }\n\n  getCurrentResult() {\n    return this.#result;\n  }\n\n  getQueries() {\n    return this.#observers.map(observer => observer.getCurrentQuery());\n  }\n\n  getObservers() {\n    return this.#observers;\n  }\n\n  getOptimisticResult(queries, combine) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(match => match.observer.getOptimisticResult(match.defaultedQueryOptions));\n    return [result, r => {\n      return this.#combineResult(r ?? result, combine);\n    }, () => {\n      return this.#trackResult(result, matches);\n    }];\n  }\n\n  #trackResult(result, matches) {\n    return matches.map((match, index) => {\n      const observerResult = result[index];\n      return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult, accessedProp => {\n        matches.forEach(m => {\n          m.observer.trackProp(accessedProp);\n        });\n      }) : observerResult;\n    });\n  }\n\n  #combineResult(input, combine) {\n    if (combine) {\n      if (!this.#combinedResult || this.#result !== this.#lastResult || combine !== this.#lastCombine) {\n        this.#lastCombine = combine;\n        this.#lastResult = this.#result;\n        this.#combinedResult = replaceEqualDeep(this.#combinedResult, combine(input));\n      }\n\n      return this.#combinedResult;\n    }\n\n    return input;\n  }\n\n  #findMatchingObservers(queries) {\n    const prevObserversMap = new Map(this.#observers.map(observer => [observer.options.queryHash, observer]));\n    const observers = [];\n    queries.forEach(options => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        });\n      } else {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: new QueryObserver(this.#client, defaultedOptions)\n        });\n      }\n    });\n    return observers;\n  }\n\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result);\n      this.#notify();\n    }\n  }\n\n  #notify() {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult;\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches);\n      const newResult = this.#combineResult(newTracked, this.#options?.combine);\n\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach(listener => {\n            listener(this.#result);\n          });\n        });\n      }\n    }\n  }\n\n};\nexport { QueriesObserver };","map":{"version":3,"mappings":"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","names":["notifyManager","QueryObserver","Subscribable","replaceEqualDeep","difference","array1","array2","filter","x","includes","replaceAt","array","index","value","copy","slice","QueriesObserver","constructor","client","queries","options","setQueries","onSubscribe","listeners","size","forEach","observer","subscribe","result","onUnsubscribe","destroy","Set","notifyOptions","process","env","NODE_ENV","queryHashes","map","query","defaultQueryOptions","queryHash","length","console","warn","batch","prevObservers","newObserverMatches","match","setOptions","defaultedQueryOptions","newObservers","newResult","getCurrentResult","hasIndexChange","some","hasListeners","getQueries","getCurrentQuery","getObservers","getOptimisticResult","combine","matches","r","observerResult","notifyOnChangeProps","trackResult","accessedProp","m","trackProp","input","prevObserversMap","Map","observers","defaultedOptions","get","push","indexOf","previousResult","newTracked","listener"],"sources":["/Users/harshini/Desktop/Social/client/node_modules/@tanstack/query-core/src/queriesObserver.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { NotifyOptions } from './queryObserver'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  return array1.filter((x) => !array2.includes(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #observers: Array<QueryObserver>\n  #combinedResult?: TCombinedResult\n  #lastCombine?: CombineFn<TCombinedResult>\n  #lastResult?: Array<QueryObserverResult>\n  #observerMatches: Array<QueryObserverMatch> = []\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions<any, any, any, any, any>>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#options = options\n    this.#queries = []\n    this.#observers = []\n    this.#result = []\n\n    this.setQueries(queries)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    if (process.env.NODE_ENV !== 'production') {\n      const queryHashes = queries.map(\n        (query) => this.#client.defaultQueryOptions(query).queryHash,\n      )\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\n          '[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.',\n        )\n      }\n    }\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n      this.#observerMatches = newObserverMatches\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions, notifyOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): Array<QueryObserverResult> {\n    return this.#result\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine)\n      },\n      () => {\n        return this.#trackResult(result, matches)\n      },\n    ]\n  }\n\n  #trackResult(\n    result: Array<QueryObserverResult>,\n    matches: Array<QueryObserverMatch>,\n  ) {\n    return matches.map((match, index) => {\n      const observerResult = result[index]!\n      return !match.defaultedQueryOptions.notifyOnChangeProps\n        ? match.observer.trackResult(observerResult, (accessedProp) => {\n            // track property on all observers to ensure proper (synchronized) tracking (#7000)\n            matches.forEach((m) => {\n              m.observer.trackProp(accessedProp)\n            })\n          })\n        : observerResult\n    })\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): TCombinedResult {\n    if (combine) {\n      if (\n        !this.#combinedResult ||\n        this.#result !== this.#lastResult ||\n        combine !== this.#lastCombine\n      ) {\n        this.#lastCombine = combine\n        this.#lastResult = this.#result\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input),\n        )\n      }\n\n      return this.#combinedResult\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObserversMap = new Map(\n      this.#observers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const observers: Array<QueryObserverMatch> = []\n\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const match = prevObserversMap.get(defaultedOptions.queryHash)\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match,\n        })\n      } else {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: new QueryObserver(this.#client, defaultedOptions),\n        })\n      }\n    })\n\n    return observers\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result)\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches)\n      const newResult = this.#combineResult(newTracked, this.#options?.combine)\n\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result)\n          })\n        })\n      }\n    }\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n"]},"metadata":{},"sourceType":"module"}