{"ast":null,"code":"// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, sleep } from \"./utils.js\";\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode ?? \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\n\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options?.revert;\n    this.silent = options?.silent;\n  }\n\n};\n\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\n\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  const thenable = pendingThenable();\n\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort?.();\n    }\n  };\n\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n\n  const canContinue = () => focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n\n  const resolve = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess?.(value);\n      continueFn?.();\n      thenable.resolve(value);\n    }\n  };\n\n  const reject = value => {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError?.(value);\n      continueFn?.();\n      thenable.reject(value);\n    }\n  };\n\n  const pause = () => {\n    return new Promise(continueResolve => {\n      continueFn = value => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n\n      config.onPause?.();\n    }).then(() => {\n      continueFn = void 0;\n\n      if (!isResolved) {\n        config.onContinue?.();\n      }\n    });\n  };\n\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n\n    try {\n      promiseOrValue = initialPromise ?? config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      if (isResolved) {\n        return;\n      }\n\n      const retry = config.retry ?? (isServer ? 0 : 3);\n      const retryDelay = config.retryDelay ?? defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n\n      failureCount++;\n      config.onFail?.(failureCount, error);\n      sleep(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n\n      return thenable;\n    }\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError };","map":{"version":3,"mappings":"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","names":["focusManager","onlineManager","pendingThenable","isServer","sleep","defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","isOnline","CancelledError","Error","constructor","options","revert","silent","isCancelledError","value","createRetryer","config","isRetryCancelled","isResolved","continueFn","thenable","cancel","cancelOptions","reject","abort","cancelRetry","continueRetry","canContinue","isFocused","canRun","canStart","resolve","onSuccess","onError","pause","Promise","continueResolve","onPause","then","onContinue","run","promiseOrValue","initialPromise","fn","error","catch","retry","retryDelay","delay","shouldRetry","onFail","promise","continue","start"],"sources":["/Users/harshini/Desktop/Social/client/node_modules/@tanstack/query-core/src/retryer.ts"],"sourcesContent":["import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"module"}