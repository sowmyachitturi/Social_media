{"ast":null,"code":"// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */new Set();\n    this.#scopes = /* @__PURE__ */new Map();\n    this.#mutationId = 0;\n  }\n\n  #mutations;\n  #scopes;\n  #mutationId;\n\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n\n    this.notify({\n      type: \"added\",\n      mutation\n    });\n  }\n\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n\n    this.notify({\n      type: \"removed\",\n      mutation\n    });\n  }\n\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(m => m.state.status === \"pending\");\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find(m => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach(mutation => {\n        this.notify({\n          type: \"removed\",\n          mutation\n        });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n\n  find(filters) {\n    const defaultedFilters = {\n      exact: true,\n      ...filters\n    };\n    return this.getAll().find(mutation => matchMutation(defaultedFilters, mutation));\n  }\n\n  findAll() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.getAll().filter(mutation => matchMutation(filters, mutation));\n  }\n\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter(x => x.state.isPaused);\n    return notifyManager.batch(() => Promise.all(pausedMutations.map(mutation => mutation.continue().catch(noop))));\n  }\n\n};\n\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\n\nexport { MutationCache };","map":{"version":3,"mappings":"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","names":["notifyManager","Mutation","matchMutation","noop","Subscribable","MutationCache","constructor","config","Set","Map","build","client","options","state","mutation","mutationCache","mutationId","defaultMutationOptions","add","scope","scopeFor","scopedMutations","get","push","set","notify","type","remove","delete","length","index","indexOf","splice","canRun","mutationsWithSameScope","firstPendingMutation","find","m","status","runNext","foundMutation","isPaused","continue","Promise","resolve","clear","batch","forEach","getAll","Array","from","filters","defaultedFilters","exact","findAll","filter","event","listeners","listener","resumePausedMutations","pausedMutations","x","all","map","catch","id"],"sources":["/Users/harshini/Desktop/Social/client/node_modules/@tanstack/query-core/src/mutationCache.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n"]},"metadata":{},"sourceType":"module"}