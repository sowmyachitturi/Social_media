{"ast":null,"code":"// src/queryClient.ts\nimport { functionalUpdate, hashKey, hashQueryKeyByOptions, noop, partialMatchKey, resolveStaleTime, skipToken } from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */new Map();\n    this.#mutationDefaults = /* @__PURE__ */new Map();\n    this.#mountCount = 0;\n  }\n\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async focused => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async online => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters,\n      fetchStatus: \"fetching\"\n    }).length;\n  }\n\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters,\n      status: \"pending\"\n    }).length;\n  }\n\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({\n      queryKey\n    });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n\n    return Promise.resolve(cachedData);\n  }\n\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(_ref => {\n      let {\n        queryKey,\n        state\n      } = _ref;\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({\n      queryKey\n    });\n    const query = this.#queryCache.get(defaultedOptions.queryHash);\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n\n    if (data === void 0) {\n      return void 0;\n    }\n\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options,\n      manual: true\n    });\n  }\n\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(() => this.#queryCache.findAll(filters).map(_ref2 => {\n      let {\n        queryKey\n      } = _ref2;\n      return [queryKey, this.setQueryData(queryKey, updater, options)];\n    }));\n  }\n\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({\n      queryKey\n    });\n    return this.#queryCache.get(options.queryHash)?.state;\n  }\n\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries({\n        type: \"active\",\n        ...filters\n      }, options);\n    });\n  }\n\n  cancelQueries(filters) {\n    let cancelOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const defaultedCancelOptions = {\n      revert: true,\n      ...cancelOptions\n    };\n    const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).map(query => query.cancel(defaultedCancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n\n  invalidateQueries(filters) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n\n      return this.refetchQueries({ ...filters,\n        type: filters?.refetchType ?? filters?.type ?? \"active\"\n      }, options);\n    });\n  }\n\n  refetchQueries(filters) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const fetchOptions = { ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      let promise = query.fetch(void 0, fetchOptions);\n\n      if (!fetchOptions.throwOnError) {\n        promise = promise.catch(noop);\n      }\n\n      return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n    }));\n    return Promise.all(promises).then(noop);\n  }\n\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query)) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n\n    return Promise.resolve();\n  }\n\n  getQueryCache() {\n    return this.#queryCache;\n  }\n\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    const result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n\n    const defaultedOptions = { ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    }\n\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n\n    return defaultedOptions;\n  }\n\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n\n    return { ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey && this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true\n    };\n  }\n\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n\n};\nexport { QueryClient };","map":{"version":3,"mappings":"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","names":["functionalUpdate","hashKey","hashQueryKeyByOptions","noop","partialMatchKey","resolveStaleTime","skipToken","QueryCache","MutationCache","focusManager","onlineManager","notifyManager","infiniteQueryBehavior","QueryClient","constructor","config","queryCache","mutationCache","defaultOptions","Map","mount","subscribe","focused","resumePausedMutations","onFocus","online","onOnline","unmount","isFetching","filters","findAll","fetchStatus","length","isMutating","status","getQueryData","queryKey","options","defaultQueryOptions","get","queryHash","state","data","ensureQueryData","defaultedOptions","query","build","cachedData","fetchQuery","revalidateIfStale","isStaleByTime","staleTime","prefetchQuery","Promise","resolve","getQueriesData","map","setQueryData","updater","prevData","setData","manual","setQueriesData","batch","getQueryState","removeQueries","forEach","remove","resetQueries","reset","refetchQueries","type","cancelQueries","cancelOptions","defaultedCancelOptions","revert","promises","cancel","all","then","catch","invalidateQueries","invalidate","refetchType","fetchOptions","cancelRefetch","filter","isDisabled","promise","fetch","throwOnError","retry","fetchInfiniteQuery","behavior","pages","prefetchInfiniteQuery","ensureInfiniteQueryData","isOnline","getQueryCache","getMutationCache","getDefaultOptions","setDefaultOptions","setQueryDefaults","set","getQueryDefaults","defaults","values","result","queryDefault","Object","assign","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","refetchOnReconnect","networkMode","suspense","persister","queryFn","enabled","defaultMutationOptions","mutations","clear"],"sources":["/Users/harshini/Desktop/Social/client/node_modules/@tanstack/query-core/src/queryClient.ts"],"sourcesContent":["import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<\n    TQueryFilters extends QueryFilters<any, any, any, any> = QueryFilters,\n  >(filters?: TQueryFilters): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get(options.queryHash)?.state.data as\n      | TInferredQueryFnData\n      | undefined\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<\n      any,\n      any,\n      any,\n      any\n    > = QueryFilters<TQueryFnData>,\n    TInferredQueryFnData = TQueryFilters extends QueryFilters<\n      infer TData,\n      any,\n      any,\n      any\n    >\n      ? TData\n      : TQueryFnData,\n  >(\n    filters: TQueryFilters,\n  ): Array<[QueryKey, TInferredQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TInferredQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): TInferredQueryFnData | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<\n      any,\n      any,\n      any,\n      any\n    > = QueryFilters<TQueryFnData>,\n    TInferredQueryFnData = TQueryFilters extends QueryFilters<\n      infer TData,\n      any,\n      any,\n      any\n    >\n      ? TData\n      : TQueryFnData,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TInferredQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TInferredQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: InvalidateQueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: RefetchQueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TContext = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}